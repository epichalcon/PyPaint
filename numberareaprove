import numpy as np
import cv2

original_edges = cv2.imread("edges.png")

print(original_edges.shape)

def find_current_contour(mat, x, y):
    current_contour = []
    directions = [(-1, 0),
                  (1, 0),
                  (0, -1),
                  (0, 1),
                  ]

    queue = [(x,y)]
    original = (x, y)
    cx, cy = 0,0


    while (queue):
        x, y = queue.pop(0)
        if not( 0 <= x < mat.shape[0] and 0 <= y < mat.shape[1]) or mat[x,y] == 0: # es un borde
            continue

        current_contour.append((x,y))
        mat[x, y] = 0
        queue.extend((x+dx, y +dy) for dx, dy in directions if 0<= x +dx < mat.shape[0] and 0 <= y +dy < mat.shape[1])
        #return np.array(current_contour, dtype=np.int32)

        
    if len(current_contour) < 15:
        return np.array([])
    return np.array(current_contour, dtype=np.int32)

def reposition_number(cx, cy, contour, font_scale, text):
    is_inside = cv2.pointPolygonTest(contour,(cx,cy), False)

    if is_inside >= 0:
        return cx,cy
    else:
        x,y,w,h = cv2.boundingRect(contour)
        text_size = cv2.getTextSize(text, cv2.FONT_HERSHEY_PLAIN, font_scale, 1)[0]
        new_cx = x- text_size[0]-3
        new_cy = cy
        return new_cx, new_cy

    #if (cx, cy) not in current_contour:
     #   return cx // len(current_contour), cy // len(current_contour)

    #else:
     #   return original   

def load_image():
    with open('temp.txt', 'r') as f:
        image = np.array(f.readline()[1:-2].split(', '), dtype=np.uint8).reshape(original_edges.shape[:-1])
        edges = np.array(f.readline()[1:-2].split(', '), dtype=np.uint8).reshape(original_edges.shape[:-1])
    return image, edges


def load_demo():
    image = np.array([
             [  1,   1,   1,   2],
             [  1,   1,   2,   2],
             [  1,   2,   2,   2],
             ])
    edges = np.array([
             [255, 255,   0, 255],
             [255,   0, 255, 255],
             [  0, 255, 255, 255],
            ])
    return image, edges

def get_font_scale(contour):
    area= len(contour)
    if area<40:
        return 0.4
    elif area<250:
        return 0.7
    else:
        return 1.0
    
image, edges = load_image()
    

visited = set()
resulting_numbers = {} # diccionario con una coordenada como clave y el color como valor

contours= []
print('Calculating centroids...')
for x, row in enumerate(edges):
    for y, color in enumerate(row):
        if color != 0:
            contour = find_current_contour(edges, x, y)
            if len(contour) >= 15:
                contours.append(contour)
                cx,cy = tuple (np.mean(contour, axis=0, dtype=int))
                number =image[x,y]
                font_scale = get_font_scale(contour)
                new_cx, new_cy= reposition_number(cx,cy,contour, font_scale, str(number))
                resulting_numbers [(new_cx,new_cy)] = (number, font_scale)


print('Drawing numbers...')
for point, (number, scale) in resulting_numbers.items():
    px, py = point  
    cv2.putText(original_edges, str(number), (py - 3, px + 3), cv2.FONT_HERSHEY_PLAIN, scale, (0, 0, 255))

cv2.imwrite('numbers.png', original_edges)

cv2.imshow('edges', original_edges)
cv2.waitKey(0)
